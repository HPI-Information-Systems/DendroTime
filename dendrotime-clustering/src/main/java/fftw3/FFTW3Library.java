package fftw3;

import com.sun.jna.Callback;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.NativeLong;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.Structure;
import com.sun.jna.ptr.DoubleByReference;
import com.sun.jna.ptr.FloatByReference;
import com.sun.jna.ptr.IntByReference;

import java.nio.DoubleBuffer;
import java.nio.IntBuffer;

/**
 * JNA Wrapper for library <b>FFTW3</b>. Install FFTW3 on Linux using <code>sudo apt install libfftw3-3</code>.<br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.free.fr/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface FFTW3Library extends Library {
    public static final String JNA_LIBRARY_NAME = "fftw3";
    public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(JNA_LIBRARY_NAME);
    public static final FFTW3Library INSTANCE = (FFTW3Library) Native.load(JNA_LIBRARY_NAME, FFTW3Library.class);

    /** Fast planning but potentially slower FFT performance. */
    public static final int FFTW_ESTIMATE = (1 << 6);
    /** Longer planning time but better FFT performance. */
    public static final int FFTW_MEASURE = (0);
    /** Very long planning but near-optimal FFT performance. */
    public static final int FFTW_PATIENT = (1 << 5);
    /** Exhaustive planning but near-optimal FFT performance. */
    public static final int FFTW_EXHAUSTIVE = (1 << 3);
    public static final int FFTW_PRESERVE_INPUT = (1 << 4);
    public static final int FFTW_DESTROY_INPUT = (1 << 0);
    public static final int FFTW_BELIEVE_PCOST = (1 << 8);
    public static final int FFTW_NO_NONTHREADED = (1 << 10);
    public static final int FFTW_NO_FIXED_RADIX_LARGE_N = (1 << 19);
    public static final int FFTW_BACKWARD = (1);
    public static final int FFTW_UNALIGNED = (1 << 1);
    public static final int FFTW_NO_SLOW = (1 << 18);
    public static final int FFTW_ESTIMATE_PATIENT = (1 << 7);
    public static final int FFTW_NO_VRECURSE = (1 << 16);
    public static final int FFTW_NO_BUFFERING = (1 << 11);
    public static final int FFTW_NO_DFT_R2HC = (1 << 9);
    public static final double FFTW_NO_TIMELIMIT = (-1.0);
    public static final int FFTW_NO_INDIRECT_OP = (1 << 12);
    public static final int FFTW_FORWARD = (-1);
    public static final int FFTW_CONSERVE_MEMORY = (1 << 2);
    public static final int FFTW_NO_SIMD = (1 << 17);
    public static final int FFTW_NO_RANK_SPLITS = (1 << 14);
    public static final int FFTW_ALLOW_LARGE_GENERIC = (1 << 13);
    public static final int FFTW_NO_VRANK_SPLITS = (1 << 15);
    public static final int FFTW_WISDOM_ONLY = (1 << 21);
    public static final int FFTW_ALLOW_PRUNING = (1 << 20);

    /**
     * Original signature : <code>void fftw_execute(const fftw_plan)</code><br>
     */
    void fftw_execute(FFTW3Library.fftw_plan p);

    /**
     * Original signature : <code>fftw_plan fftw_plan_dft_r2c(int, const int*, double*, double*, unsigned)</code><br>
     */
    FFTW3Library.fftw_plan fftw_plan_dft_r2c(int rank, IntBuffer n, DoubleBuffer in, DoubleBuffer out, int flags);

    /**
     * Original signature : <code>fftw_plan fftw_plan_dft_c2r(int, const int*, double*, double*, unsigned)</code><br>
     */
    FFTW3Library.fftw_plan fftw_plan_dft_c2r(int rank, IntBuffer n, DoubleBuffer in, DoubleBuffer out, int flags);

    /**
     * Original signature : <code>void fftw_destroy_plan(fftw_plan)</code><br>
     */
    void fftw_destroy_plan(FFTW3Library.fftw_plan p);

    /**
     * Original signature : <code>void fftw_forget_wisdom()</code><br>
     */
    void fftw_forget_wisdom();

    /**
     * Original signature : <code>void fftw_cleanup()</code><br>
     */
    void fftw_cleanup();

    /**
     * Original signature : <code>void fftw_set_timelimit(double)</code><br>
     */
    void fftw_set_timelimit(double double1);

    /**
     * Original signature : <code>void fftw_plan_with_nthreads(int)</code><br>
     */
    void fftw_plan_with_nthreads(int nthreads);

    /**
     * Original signature : <code>int fftw_init_threads()</code><br>
     */
    int fftw_init_threads();

    /**
     * Original signature : <code>void fftw_cleanup_threads()</code><br>
     */
    void fftw_cleanup_threads();

    /**
     * Original signature : <code>void fftw_export_wisdom_to_file(FILE*)</code><br>
     */
    void fftw_export_wisdom_to_file(Pointer output_file);

    /**
     * Original signature : <code>char* fftw_export_wisdom_to_string()</code><br>
     */
    Pointer fftw_export_wisdom_to_string();

    /**
     * Original signature : <code>int fftw_import_system_wisdom()</code><br>
     */
    int fftw_import_system_wisdom();

    /**
     * Original signature : <code>int fftw_import_wisdom_from_file(FILE*)</code><br>
     */
    int fftw_import_wisdom_from_file(Pointer input_file);

    /**
     * Original signature : <code>int fftw_import_wisdom_from_string(const char*)</code><br>
     */
    int fftw_import_wisdom_from_string(String input_string);

    /**
     * Original signature : <code>void fftw_fprint_plan(const fftw_plan, FILE*)</code><br>
     */
    void fftw_fprint_plan(FFTW3Library.fftw_plan p, Pointer output_file);

    /**
     * Original signature : <code>void fftw_print_plan(const fftw_plan)</code><br>
     */
    void fftw_print_plan(FFTW3Library.fftw_plan p);

    /**
     * Original signature : <code>void* fftw_malloc(size_t)</code><br>
     */
    Pointer fftw_malloc(NativeLong n);

    /**
     * Original signature : <code>void fftw_free(void*)</code><br>
     */
    void fftw_free(Pointer p);

    /**
     * Original signature : <code>double fftw_estimate_cost(const fftw_plan)</code><br>
     */
    double fftw_estimate_cost(FFTW3Library.fftw_plan p);

    public static final class fftw_version {
        private static Pointer fftw_version;

        public static synchronized Pointer get() {
            if (fftw_version == null)
                fftw_version = FFTW3Library.JNA_NATIVE_LIB.getGlobalVariableAddress("fftw_version");
            return fftw_version;
        }
    }

    public static class fftw_plan extends PointerType {
        public fftw_plan(Pointer address) {
            super(address);
        }

        public fftw_plan() {
            super();
        }
    }
}
