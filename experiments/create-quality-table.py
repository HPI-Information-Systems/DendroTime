import argparse
from pathlib import Path
import sys

import numpy as np
import pandas as pd


OUTPUT_FILENAME = Path("quality-table.tex")

template = """% DO NOT MODIFY!
% This file is automatically generated
\\begin{{tabular}}{{ll@{{\\hspace{{{col_margin}}}}}ccc@{{\\hspace{{{col_margin}}}}}c}}
    \\toprule
    && \\multicolumn{{3}}{{c@{{\\hspace{{{col_margin}}}}}}}{{\\textbf{{\\gls{{whsrauc}}}}}} & \\textbf{{\\gls{{whs}}}} \\\\
    \\cmidrule(r{{{col_margin}}}){{3-5}}
    \\textbf{{Diss.}} & \\textbf{{Linkage}} & \\textbf{{\\approxAsc{{}}}} & \\textbf{{\\preClust{{}}}} & \\textbf{{\\fcfs{{}}}} & \\textbf{{\\jet{{}}}} \\\\
    \\midrule
{content}
    \\bottomrule
\\end{{tabular}}
"""
first_row_template = "    \\multirow{{{n_linkages}}}{{*}}{{\\gls{{{distance}}}}} & {linkage} & {approx_asc:.2f} & {pre_clust:.2f} & {fcfs:.2f} & {jet:.2f} \\\\"
row_template = "        & {linkage} & {approx_asc:.2f} & {pre_clust:.2f} & {fcfs:.2f} & {jet:.2f} \\\\"
template_no_jet = """% DO NOT MODIFY!
% This file is automatically generated
\\begin{{tabular}}{{ll@{{\\hspace{{{col_margin}}}}}ccc}}
    \\toprule
    && \\multicolumn{{3}}{{c}}{{\\textbf{{\\gls{{whsrauc}}}}}} \\\\
    \\cmidrule(r){{3-5}}
    \\textbf{{Diss.}} & \\textbf{{Linkage}} & \\textbf{{\\approxAsc{{}}}} & \\textbf{{\\preClust{{}}}} & \\textbf{{\\fcfs{{}}}} \\\\
    \\midrule
{content}
    \\bottomrule
\\end{{tabular}}
"""
first_row_template_no_jet = "    \\multirow{{{n_linkages}}}{{*}}{{\\gls{{{distance}}}}} & {linkage} & {approx_asc:.2f} & {pre_clust:.2f} & {fcfs:.2f} \\\\"
row_template_no_jet = (
    "        & {linkage} & {approx_asc:.2f} & {pre_clust:.2f} & {fcfs:.2f} \\\\"
)


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--include-euclidean", action="store_true", help="Include euclidean distance"
    )
    parser.add_argument(
        "--include-ward", action="store_true", help="Include ward linkage"
    )
    parser.add_argument(
        "--exclude-jet",
        action="store_true",
        help="Exclude JET from the table",
    )
    return parser.parse_args()


def main(include_euclidean=False, include_ward=False, exclude_jet=False):
    # load results from jet execution
    df_jet = pd.read_csv("06-jet/results/results.csv")
    df_jet["strategy"] = "JET"
    df_jet["distance"] = np.tile(["sbd", "msm", "dtw"], df_jet.shape[0] // 3)
    df_jet.replace(-1, np.nan, inplace=True)
    # JET does only support ward linkage:
    df_jet["linkage"] = "ward"
    df_jet = df_jet.groupby(["distance", "linkage"])[["whs"]].agg(
        ["min", "mean", "median", "max", "std"]
    )
    df_jet.columns = df_jet.columns.droplevel(0)

    # load results from system execution
    df_dendrotime = pd.read_csv("04-dendrotime/results/aggregated-runtimes.csv")
    df_dendrotime["runtime"] = df_dendrotime["finished"]
    df_dendrotime = df_dendrotime.drop(
        columns=[
            "initializing",
            "approximating",
            "computingfulldistances",
            "finalizing",
            "finished",
            *[f"runtime_{t:.1f}" for t in np.arange(0.1, 1.0, 0.1)],
        ]
    )
    df_dendrotime = df_dendrotime.groupby(["distance", "linkage", "strategy"])[
        ["whs_r_auc"]
    ].agg(["min", "mean", "median", "max", "std"])

    distances = set(df_dendrotime.index.get_level_values("distance").unique()) | set(
        df_jet.index.get_level_values("distance").unique()
    )
    if not include_euclidean:
        distances = distances - {"euclidean"}
    distances = sorted(distances)
    linkages = set(df_dendrotime.index.get_level_values("linkage").unique()) | set(
        df_jet.index.get_level_values("linkage").unique()
    )
    # ward is always at the end
    linkages = linkages - {"ward"}
    if exclude_jet and not include_ward:
        linkages = sorted(linkages)
    else:
        linkages = sorted(linkages) + ["ward"]

    print(f"Creating quality table ...", file=sys.stderr)
    print(f"  distances: {distances}", file=sys.stderr)
    print(f"  linkages: {linkages}", file=sys.stderr)

    col_margin = "2em"
    lines = []
    for i, distance in enumerate(distances):
        for j, linkage in enumerate(linkages):
            values = {"distance": distance, "linkage": linkage}
            if (distance, linkage) in df_dendrotime.index and (
                include_ward or linkage != "ward"
            ):
                row = df_dendrotime.loc[(distance, linkage)]
                values.update(
                    {
                        "approx_asc": row.loc[
                            "approx_distance_ascending", ("whs_r_auc", "mean")
                        ],
                        "pre_clust": row.loc["pre_clustering", ("whs_r_auc", "mean")],
                        "fcfs": row.loc["fcfs", ("whs_r_auc", "mean")],
                    }
                )
            else:
                values.update(
                    {
                        "approx_asc": np.nan,
                        "pre_clust": np.nan,
                        "fcfs": np.nan,
                    }
                )
            if (distance, linkage) in df_jet.index:
                row_jet = df_jet.loc[(distance, "ward")]
                values["jet"] = row_jet["mean"]
            else:
                values["jet"] = np.nan

            if j == 0:
                values["n_linkages"] = len(linkages)
                if exclude_jet:
                    line = first_row_template_no_jet.format(**values)
                else:
                    line = first_row_template.format(**values)
            else:
                if exclude_jet:
                    line = row_template_no_jet.format(**values)
                else:
                    line = row_template.format(**values)
            if j == len(linkages) - 1 and i != len(distances) - 1:
                line += "[0.5em]"
            lines.append(line)

    content = "\n".join(lines)
    content = content.replace("nan", "-")
    if exclude_jet:
        text = template_no_jet.format(content=content, col_margin=col_margin)
    else:
        text = template.format(content=content, col_margin=col_margin)

    print(f"  writing latex table to {OUTPUT_FILENAME} ...", file=sys.stderr)
    with open(OUTPUT_FILENAME, "w") as f:
        f.write(text)
    print("... done.", file=sys.stderr)


if __name__ == "__main__":
    args = parse_args()
    main(
        include_euclidean=args.include_euclidean,
        include_ward=args.include_ward,
        exclude_jet=args.exclude_jet,
    )
