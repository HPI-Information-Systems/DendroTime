import sys
import argparse
from pathlib import Path

from matplotlib import pyplot as plt
import numpy as np
import pandas as pd

sys.path.append(str(Path(__file__).parent.parent))
from plt_commons import distance_name_mapping, linkages

OUTPUT_FILENAME = Path("speedup-table.tex")

selected_strategies = (
    "fcfs",
    "approx_distance_ascending",
    "pre_clustering",
)
distance_order = ["euclidean", "lorentzian", "sbd", "dtw", "msm", "kdtw"]
template = """% DO NOT MODIFY!
% This file is automatically generated
{{\\setlength{{\\tabcolsep}}{{2pt}}%
\\newcommand{{\\dx}}{{\\hspace{{8pt}}}}%
\\begin{{tabular}}{{@{{}}l{column_specs}@{{}}}}
    \\toprule
    {distance_headers} \\\\
    {linkage_headers} \\\\
    \\midrule
{content}
    \\bottomrule
\\end{{tabular}}}}
"""
column_spec_template = "@{{\\dx}}{cols}"
distance_header_template = "& \\multicolumn{{{n_linkages}}}{{@{{}}c@{{}}}}{{{distance}}}"
linkage_header_template = "& \\linkage{{{linkage}}}"
strategy_fcfs = "\\dendrotime{} \\fcfs{}"
strategy_approx_asc = "\\dendrotime{} \\approxAsc{}"
strategy_pre_clust = "\\dendrotime{} \\preClust{}"
strategy_name_mapping = {
    "fcfs": strategy_fcfs,
    "approx_distance_ascending": strategy_approx_asc,
    "pre_clustering": strategy_pre_clust,
}
linkage_name_mapping = {
    "single": "sngl",
    "complete": "cmpl",
    "average": "avg",
    "weighted": "wgtd",
    "ward": "ward",
}


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--distances",
        nargs="*",
        default=distance_order,
        help="Distances to include in the plot (default: all)",
    )
    parser.add_argument(
        "--linkages",
        nargs="*",
        default=linkages,
        help="Linkages to include in the plot (default: all)",
    )
    parser.add_argument(
        "-c",
        "--correct-dendrotime-runtime",
        action="store_true",
        help="Correct dendrotime runtime by removing quality measurement overhead",
    )
    parser.add_argument(
        "-s",
        "--short-linkage-names",
        action="store_true",
        help="Use short linkage names in the table",
    )
    return parser.parse_args()


def main(
    selected_distances,
    selected_linkages,
    correct_dendrotime_runtime=False,
    short_linkage_names=False,
):
    # load results from parallel execution
    df_parallel = pd.read_csv("07-parallel-hac/results/aggregated-runtimes.csv")
    df_parallel["strategy"] = "parallel"
    df_parallel = df_parallel[df_parallel["phase"] == "Finished"]
    df_parallel = df_parallel.drop(columns=["phase"])
    df_parallel["whs"] = 1.0

    # load results from system execution
    df_dendrotime = pd.read_csv("04-dendrotime/results/aggregated-runtimes.csv")
    df_dendrotime["runtime_1.0"] = df_dendrotime["finished"]
    df_dendrotime = df_dendrotime.drop(
        columns=[
            "initializing",
            "approximating",
            "computingfulldistances",
            "finalizing",
            "finished",
            "whs_r_auc"
        ]
    )
    runtime_cols = [c for c in df_dendrotime.columns if c.startswith("runtime")]
    if correct_dendrotime_runtime:
        # --- runtime correction (remove quality measurement overhead)
        df_dendrotime_nqa = pd.read_csv(
            "08-dendrotime-no-quality/results/aggregated-runtimes.csv"
        )
        df_dendrotime_nqa["runtime_nqa"] = df_dendrotime_nqa["finished"]
        df_dendrotime_nqa = df_dendrotime_nqa.drop(
            columns=[
                "initializing",
                "approximating",
                "computingfulldistances",
                "finalizing",
                "finished",
            ]
        )
        df_dendrotime_nqa = df_dendrotime_nqa.set_index(
            ["dataset", "distance", "linkage", "strategy"]
        ).sort_index()
        df_tmp = df_dendrotime.set_index(
            ["dataset", "distance", "linkage", "strategy"]
        ).sort_index()
        df_tmp = pd.merge(
            df_tmp, df_dendrotime_nqa, how="left", left_index=True, right_index=True
        )
        df_tmp["runtime_correction_factor"] = (
            df_tmp["runtime_1.0"] / df_tmp["runtime_nqa"]
        )
        df_tmp["runtime_correction_factor"] = df_tmp[
            "runtime_correction_factor"
        ].fillna(1.0)
        for c in runtime_cols:
            df_tmp[c] = df_tmp[c] / df_tmp["runtime_correction_factor"]
        df_dendrotime = df_tmp.drop(
            columns=["runtime_nqa", "runtime_correction_factor"]
        ).reset_index()
        # --- end runtime correction

    # prepare dfs for merging
    df_parallel = df_parallel.set_index(
        ["dataset", "distance", "linkage"]
    ).sort_index()
    df_parallel.drop(columns=["ARI", "whs", "strategy"], inplace=True)
    df_parallel.rename(columns={"runtime": "runtime_parallel"}, inplace=True)

    df_dendrotime = df_dendrotime.set_index(
        ["dataset", "distance", "linkage"]
    ).sort_index()

    # merge dfs and convert to relative runtimes
    df = pd.merge(
        df_dendrotime, df_parallel, how="left", left_index=True, right_index=True
    )
    df = df.reset_index()
    del df_dendrotime
    del df_parallel
    for c in runtime_cols:
        df[c] /= df["runtime_parallel"]

    distances = df["distance"].unique().tolist()
    distances = [d for d in distances if d in selected_distances]
    distances = sorted(distances, key=lambda x: distance_order.index(x))
    linkages = df["linkage"].unique().tolist()
    linkages = [l for l in linkages if l in selected_linkages]
    linkages = sorted(linkages)

    df = (
        df.groupby(["distance", "linkage", "strategy"])[["runtime_0.8"]]
            .mean()
            .reset_index()
            .pivot_table(
                index=["distance", "linkage"],
                columns="strategy",
                values="runtime_0.8",
            )
            .sort_index(
                key=lambda index: [distance_order.index(d) for d in index] if index.name == "distance" else index
            )
            [["fcfs", "approx_distance_ascending", "pre_clustering"]]
    )

    print(f"Creating speedup table ...", file=sys.stderr)
    print(f"  distances: {distances}", file=sys.stderr)
    print(f"  linkages: {linkages}", file=sys.stderr)

    n_linkages = len(linkages)
    n_distances = len(distances)
    column_specs = "".join([
        column_spec_template.format(cols="c"*n_linkages)
        for _ in range(n_distances)
    ])
    distance_headers = "\n    ".join([
        distance_header_template.format(
            distance=distance_name_mapping[distance], n_linkages=n_linkages
        )
        for distance in distances
    ])
    linkage_headers = " ".join([
        linkage_header_template.format(
            linkage=linkage_name_mapping[linkage] if short_linkage_names else linkage
        )
        for _ in range(n_distances)
        for linkage in linkages
    ])

    lines = []
    for strategy in selected_strategies:
        line = ["    ", strategy_name_mapping[strategy]]
        for distance in distances:
            for linkage in linkages:
                x = df.loc[(distance, linkage), strategy]
                if np.all(df.loc[(distance, linkage), :] >= x):
                    line.append(f" & \\textbf{{{x:.2f}}}")
                else:
                    line.append(f" & {x:.2f}")
        line.append(" \\\\")
        lines.append("".join(line))

    content = "\n".join(lines)
    content = content.replace("nan", "-")
    text = template.format(
        content=content, column_specs=column_specs,
        distance_headers=distance_headers,
        linkage_headers=linkage_headers
    )

    with pd.option_context("display.max_rows", None, "display.max_columns", None):
        print(df)

    print(f"  writing latex table to {OUTPUT_FILENAME} ...", file=sys.stderr)
    with open(OUTPUT_FILENAME, "w") as f:
        f.write(text)
    print("... done.", file=sys.stderr)



if __name__ == "__main__":
    args = parse_args()
    main(
        selected_distances=args.distances,
        selected_linkages=args.linkages,
        correct_dendrotime_runtime=args.correct_dendrotime_runtime,
        short_linkage_names=args.short_linkage_names,
    )
